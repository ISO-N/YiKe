# 忆刻 (YiKe) v3.0 技术设计文档 (TDD)

## 概述

本文档定义忆刻 v3.0 版本（学习指南内嵌、Windows 桌面端、局域网数据同步）的技术实现方案。

---

## 一、学习指南内嵌（F10）

### 1.1 技术方案

#### 依赖配置

```yaml
dependencies:
  flutter:
    sdk: flutter
  flutter_markdown: ^0.6.22
  markdown: ^7.2.2

  # 代码高亮（可选）
  flutter_highlight: ^0.7.0
```

#### 资源文件结构

```
assets/
└── markdown/
    └── learning_guide.md   # 学习指南（v3 开发时从 docs/prd/忆刻学习指南.md 同步，单一事实源）
```

### 1.2 文件改动

| 文件 | 改动类型 | 说明 |
|------|----------|------|
| `pubspec.yaml` | 修改 | 添加 flutter_markdown 依赖 |
| `shell_scaffold.dart` | 修改 | 新增帮助 Tab |
| `app_router.dart` | 修改 | 新增 /help 路由 |
| `app_strings.dart` | 修改 | 新增字符串常量 |
| `main.dart` | 修改 | 配置 pubspec.yaml assets |

#### pubspec.yaml 新增

```yaml
flutter:
  assets:
    - assets/markdown/
```

### 1.3 新增文件

#### 1.3.1 帮助页面

```dart
// 文件：lib/presentation/pages/help/help_page.dart

import 'package:flutter/material.dart';
import 'package:flutter_markdown/flutter_markdown.dart';
import 'package:flutter/services.dart';

/// 帮助页 - 展示学习指南
class HelpPage extends StatelessWidget {
  const HelpPage({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('忆刻学习指南'),
      ),
      body: FutureBuilder<String>(
        future: rootBundle.loadString('assets/markdown/learning_guide.md'),
        builder: (context, snapshot) {
          if (!snapshot.hasData) {
            return const Center(child: CircularProgressIndicator());
          }
          return Markdown(
            data: snapshot.data!,
            selectable: true,
            styleSheet: MarkdownStyleSheet(
              h1: Theme.of(context).textTheme.headlineMedium,
              h2: Theme.of(context).textTheme.titleLarge,
              p: Theme.of(context).textTheme.bodyMedium,
              // 深色/浅色自动适配
            ),
          );
        },
      ),
    );
  }
}
```

### 1.4 路由配置

```dart
// app_router.dart 新增
GoRoute(
  path: '/help',
  pageBuilder: (context, state) => const NoTransitionPage(child: HelpPage()),
),
```

### 1.5 底部导航修改

```dart
// shell_scaffold.dart 修改
NavigationDestination(
  icon: Icon(Icons.help_outline),
  selectedIcon: Icon(Icons.help),
  label: '帮助',  // 新增
),
```

---

## 二、Windows 桌面端支持（F11）

### 2.1 环境配置

#### pubspec.yaml 修改

```yaml
dependencies:
  flutter:
    sdk: flutter

  # 桌面端窗口管理
  window_manager: ^0.4.2
  tray_manager: ^0.2.3

  # 桌面端数据库
  sqlite3_flutter_libs: ^0.5.24

  # 安全存储
  flutter_secure_storage: ^9.2.2
  flutter_secure_storage_windows: ^3.1.1

dev_dependencies:
  flutter_test:
    sdk: flutter
  flutter_lints: ^4.0.0
```

#### Windows 平台配置

```yaml
# windows/CMakeLists.txt 无需修改
# Flutter 桌面默认支持 SQLite
```

### 2.2 窗口管理

#### 2.2.1 入口文件修改

```dart
// lib/main.dart

import 'package:flutter/material.dart';
import 'package:window_manager/window_manager.dart';

Future<void> main() async {
  WidgetsFlutterBinding.ensureInitialized();

  // 仅桌面端初始化窗口管理
  if (kIsWeb) {
    // Web 平台不做处理
  } else if (Platform.isWindows || Platform.isMacOS || Platform.isLinux) {
    await windowManager.ensureInitialized();

    const windowOptions = WindowOptions(
      size: Size(1200, 800),
      minimumSize: Size(800, 600),
      center: true,
      backgroundColor: Colors.transparent,
      skipTaskbar: false,
      titleBarStyle: TitleBarStyle.hidden, // 自定义标题栏
      title: '忆刻',
    );

    await windowManager.waitUntilReadyToShow(windowOptions, () async {
      await windowManager.show();
      await windowManager.focus();
    });
  }

  runApp(const ProviderScope(child: YikeApp()));
}
```

#### 2.2.2 自定义标题栏组件

```dart
// lib/presentation/widgets/desktop_title_bar.dart

import 'package:flutter/material.dart';
import 'package:window_manager/window_manager.dart';

/// 桌面端自定义标题栏
class DesktopTitleBar extends StatelessWidget {
  final String title;
  final List<Widget>? actions;

  const DesktopTitleBar({
    super.key,
    required this.title,
    this.actions,
  });

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onPanStart: (_) => windowManager.startDragging(),
      child: Container(
        height: 32,
        color: Theme.of(context).colorScheme.surface,
        child: Row(
          children: [
            const SizedBox(width: 8),
            // 应用图标
            Icon(
              Icons.school,
              size: 16,
              color: Theme.of(context).colorScheme.primary,
            ),
            const SizedBox(width: 8),
            Text(title, style: const TextStyle(fontSize: 12)),
            const Spacer(),
            if (actions != null) ...actions!,
            // 窗口控制按钮
            _WindowButtons(),
          ],
        ),
      ),
    );
  }
}

class _WindowButtons extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Row(
      children: [
        _WindowButton(
          icon: Icons.remove,
          onPressed: windowManager.minimize,
          hoverColor: Colors.grey[300],
        ),
        _WindowButton(
          icon: Icons.crop_square,
          onPressed: () async {
            if (await windowManager.isMaximized()) {
              windowManager.unmaximize();
            } else {
              windowManager.maximize();
            }
          },
          hoverColor: Colors.grey[300],
        ),
        _WindowButton(
          icon: Icons.close,
          onPressed: windowManager.close,
          hoverColor: Colors.red,
          hoverIconColor: Colors.white,
        ),
      ],
    );
  }
}

class _WindowButton extends StatefulWidget {
  final IconData icon;
  final VoidCallback onPressed;
  final Color? hoverColor;
  final Color? hoverIconColor;

  const _WindowButton({
    required this.icon,
    required this.onPressed,
    this.hoverColor,
    this.hoverIconColor,
  });

  @override
  State<_WindowButton> createState() => _WindowButtonState();
}

class _WindowButtonState extends State<_WindowButton> {
  bool _isHovering = false;

  @override
  Widget build(BuildContext context) {
    return MouseRegion(
      onEnter: (_) => setState(() => _isHovering = true),
      onExit: (_) => setState(() => _isHovering = false),
      child: GestureDetector(
        onTap: widget.onPressed,
        child: Container(
          width: 46,
          height: 32,
          color: _isHovering ? widget.hoverColor : Colors.transparent,
          child: Icon(
            widget.icon,
            size: 16,
            color: _isHovering
                ? (widget.hoverIconColor ?? Colors.black)
                : Colors.grey[600],
          ),
        ),
      ),
    );
  }
}
```

### 2.3 系统托盘

#### 2.3.1 托盘服务

```dart
// lib/infrastructure/desktop/tray_service.dart

import 'package:flutter/material.dart';
import 'package:tray_manager/tray_manager.dart';

/// 系统托盘服务
class TrayService with TrayListener {
  static final TrayService _instance = TrayService._internal();
  factory TrayService() => _instance;
  TrayService._internal();

  bool _isInitialized = false;

  /// 初始化托盘
  Future<void> init() async {
    if (_isInitialized) return;

    trayManager.addListener(this);

    // 设置托盘图标
    await trayManager.setIcon('assets/icons/app_icon.png');

    // 设置托盘菜单
    await trayManager.setContextMenu(
      Menu(
        items: [
          MenuItem(
            key: 'show',
            label: '显示主窗口',
          ),
          MenuItem.separator(),
          MenuItem(
            key: 'exit',
            label: '退出',
          ),
        ],
      ),
    );

    _isInitialized = true;
  }

  /// 更新托盘图标状态
  Future<void> updateStatus(TrayStatus status) async {
    final iconPath = switch (status) {
      TrayStatus.normal => 'assets/icons/app_icon.png',
      TrayStatus.syncing => 'assets/icons/app_icon_syncing.png',
      TrayStatus.offline => 'assets/icons/app_icon_offline.png',
    };
    await trayManager.setIcon(iconPath);
  }

  @override
  void onTrayIconMouseDown() {
    // 点击托盘图标显示窗口
    windowManager.show();
    windowManager.focus();
  }

  @override
  void onTrayIconRightMouseDown() {
    trayManager.popUpContextMenu();
  }

  @override
  void onTrayMenuItemClick(MenuItem menuItem) {
    if (menuItem.key == 'show') {
      windowManager.show();
      windowManager.focus();
    } else if (menuItem.key == 'exit') {
      windowManager.close();
    }
  }

  void dispose() {
    trayManager.removeListener(this);
    trayManager.destroy();
  }
}

enum TrayStatus {
  normal,
  syncing,
  offline,
}
```

### 2.4 响应式布局

#### 2.4.1 响应式工具

```dart
// lib/core/utils/responsive_utils.dart

import 'package:flutter/material.dart';

/// 响应式布局断点
class ResponsiveBreakpoints {
  static const double mobile = 600;
  static const double tablet = 900;
  static const double desktop = 1200;
}

/// 响应式布局辅助函数
class ResponsiveUtils {
  static bool isMobile(BuildContext context) =>
      MediaQuery.of(context).size.width < ResponsiveBreakpoints.mobile;

  static bool isTablet(BuildContext context) =>
      MediaQuery.of(context).size.width >= ResponsiveBreakpoints.mobile &&
      MediaQuery.of(context).size.width < ResponsiveBreakpoints.tablet;

  static bool isDesktop(BuildContext context) =>
      MediaQuery.of(context).size.width >= ResponsiveBreakpoints.desktop;

  static int getColumnCount(BuildContext context) {
    final width = MediaQuery.of(context).size.width;
    if (width >= 1200) return 3;
    if (width >= 900) return 2;
    return 1;
  }
}
```

### 2.5 快捷键支持

```dart
// lib/presentation/widgets/desktop_shortcuts.dart

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:go_router/go_router.dart';

/// 桌面端快捷键包装器
class DesktopShortcuts extends StatelessWidget {
  final Widget child;

  const DesktopShortcuts({super.key, required this.child});

  @override
  Widget build(BuildContext context) {
    return Shortcuts(
      shortcuts: <ShortcutActivator, Intent>{
        LogicalKeySet(LogicalKeyboardKey.control, LogicalKeyboardKey.keyN):
            const NewItemIntent(),
        LogicalKeySet(LogicalKeyboardKey.control, LogicalKeyboardKey.keyR):
            const RefreshIntent(),
        LogicalKeySet(LogicalKeyboardKey.control, LogicalKeyboardKey.comma):
            const OpenSettingsIntent(),
        LogicalKeySet(LogicalKeyboardKey.control, LogicalKeyboardKey.keyH):
            const OpenHelpIntent(),
      },
      child: Actions(
        actions: <Type, Action<Intent>>{
          NewItemIntent: CallbackAction<NewItemIntent>(
            onInvoke: (_) => context.push('/input'),
          ),
          RefreshIntent: CallbackAction<RefreshIntent>(
            onInvoke: (_) {
              // 触发刷新
              return null;
            },
          ),
          OpenSettingsIntent: CallbackAction<OpenSettingsIntent>(
            onInvoke: (_) => context.go('/settings'),
          ),
          OpenHelpIntent: CallbackAction<OpenHelpIntent>(
            onInvoke: (_) => context.push('/help'),
          ),
        },
        child: Focus(
          autofocus: true,
          child: child,
        ),
      ),
    );
  }
}

class NewItemIntent extends Intent {
  const NewItemIntent();
}

class RefreshIntent extends Intent {
  const RefreshIntent();
}

class OpenSettingsIntent extends Intent {
  const OpenSettingsIntent();
}

class OpenHelpIntent extends Intent {
  const OpenHelpIntent();
}
```

---

## 三、局域网数据同步（F12）

### 3.1 数据结构设计

#### 3.1.1 同步设备表

```dart
// lib/data/database/tables/sync_devices_table.dart

/// 同步设备表
class SyncDevices extends Table {
  IntColumn get id => integer().autoIncrement()();
  TextColumn get deviceId => text().unique()();
  TextColumn get deviceName => text()();
  TextColumn get deviceType => text()(); // 'android' | 'windows' | 'ios'
  TextColumn get ipAddress => text().nullable()();
  IntColumn get lastSync => integer().nullable()();
  BoolColumn get isMaster => boolean().withDefault(const Constant(false))();
  DateTimeColumn get createdAt => dateTime().withDefault(currentDateAndTime)();
}
```

#### 3.1.2 同步状态表

```dart
// lib/data/database/tables/sync_log_table.dart

/// 同步日志表
class SyncLogs extends Table {
  IntColumn get id => integer().autoIncrement()();
  TextColumn get deviceId => text()();
  TextColumn get entityType => text()(); // 'learning_item' | 'review_task' | etc.
  IntColumn get entityId => integer()();
  TextColumn get operation => text()(); // 'create' | 'update' | 'delete'
  TextColumn get data => text()(); // JSON 数据
  IntColumn get timestamp => integer()();
  IntColumn get localVersion => integer().withDefault(const Constant(0))();
}
```

### 3.2 服务发现

#### 3.2.1 发现服务

```dart
// lib/infrastructure/sync/discovery_service.dart

import 'dart:async';
import 'dart:io';

/// 设备发现服务
class DiscoveryService {
  static final DiscoveryService _instance = DiscoveryService._internal();
  factory DiscoveryService() => _instance;
  DiscoveryService._internal();

  static const int _discoveryPort = 19876;
  static const String _broadcastAddress = '255.255.255.255';
  static const Duration _discoveryInterval = Duration(seconds: 5);

  RawDatagramSocket? _socket;
  StreamController<DiscoveredDevice>? _controller;
  Timer? _broadcastTimer;
  final Set<String> _discoveredIds = {};

  /// 设备发现流
  Stream<DiscoveredDevice> get deviceStream {
    _controller ??= StreamController<DiscoveredDevice>.broadcast();
    return _controller!.stream;
  }

  /// 初始化发现服务
  Future<void> init() async {
    try {
      _socket = await RawDatagramSocket.bind(
        InternetAddress.anyIPv4,
        _discoveryPort,
        reuseAddress: true,
        reusePort: true,
      );

      _socket!.broadcastEnabled = true;

      _socket!.listen((event) {
        if (event == RawDatagramEvent.listen) {
          final datagram = _socket!.receive();
          if (datagram != null) {
            _handleDatagram(datagram);
          }
        }
      });

      // 定时广播自身
      _startBroadcasting();
    } catch (e) {
      // 端口被占用或其他错误，降级处理
      debugPrint('Discovery service init failed: $e');
    }
  }

  /// 广播自身设备
  void _startBroadcasting() {
    _broadcastTimer?.cancel();
    _broadcastTimer = Timer.periodic(_discoveryInterval, (_) {
      _broadcastPresence();
    });
    // 立即广播一次
    _broadcastPresence();
  }

  Future<void> _broadcastPresence() async {
    if (_socket == null) return;

    final message = {
      'type': 'yike_discovery',
      'device_id': await _getDeviceId(),
      'device_name': Platform.environment['COMPUTERNAME'] ?? 'Unknown',
      'device_type': _getDeviceType(),
      'version': '1.0.0',
    };

    final data = StringBuffer();
    message.forEach((key, value) {
      data.write('$key=$value&');
    });

    try {
      _socket!.send(
        data.toString().codeUnits,
        InternetAddress(_broadcastAddress),
        _discoveryPort,
      );
    } catch (e) {
      debugPrint('Broadcast failed: $e');
    }
  }

  void _handleDatagram(Datagram datagram) {
    try {
      final message = Uri.splitQueryString(String.fromCharCodes(datagram.data));
      if (message['type'] != 'yike_discovery') return;

      final deviceId = message['device_id']!;
      // 过滤自身
      if (deviceId == _getDeviceId()) return;

      if (!_discoveredIds.contains(deviceId)) {
        _discoveredIds.add(deviceId);
        final device = DiscoveredDevice(
          deviceId: deviceId,
          deviceName: message['device_name']!,
          deviceType: message['device_type']!,
          ipAddress: datagram.address.address,
        );
        _controller?.add(device);
      }
    } catch (e) {
      debugPrint('Handle datagram failed: $e');
    }
  }

  Future<String> _getDeviceId() async {
    // 使用设备唯一标识
    return 'device_${Platform.operatingSystem}_${DateTime.now().millisecondsSinceEpoch}';
  }

  String _getDeviceType() {
    if (Platform.isAndroid) return 'android';
    if (Platform.isIOS) return 'ios';
    if (Platform.isWindows) return 'windows';
    if (Platform.isMacOS) return 'macos';
    return 'unknown';
  }

  void dispose() {
    _broadcastTimer?.cancel();
    _socket?.close();
    _controller?.close();
  }
}

/// 发现的设备
class DiscoveredDevice {
  final String deviceId;
  final String deviceName;
  final String deviceType;
  final String ipAddress;

  DiscoveredDevice({
    required this.deviceId,
    required this.deviceName,
    required this.deviceType,
    required this.ipAddress,
  });
}
```

### 3.3 数据传输

#### 3.3.1 传输服务

```dart
// lib/infrastructure/sync/transfer_service.dart

import 'dart:async';
import 'dart:convert';
import 'dart:io';

/// 数据传输服务
class TransferService {
  static final TransferService _instance = TransferService._internal();
  factory TransferService() => _instance;
  TransferService._internal();

  static const int _transferPort = 19877;
  HttpServer? _server;
  final _syncController = StreamController<SyncEvent>.broadcast();

  Stream<SyncEvent> get syncStream => _syncController.stream;

  /// 启动传输服务
  Future<void> init() async {
    _server = await HttpServer.bind(InternetAddress.anyIPv4, _transferPort);
    _server!.listen(_handleRequest);
  }

  Future<void> _handleRequest(HttpRequest request) async {
    try {
      final path = request.uri.path;
      final method = request.method;

      switch ('$method $path') {
        case 'POST /sync':
          await _handleSync(request);
          break;
        case 'GET /ping':
          request.response.write('{"status":"ok"}');
          await request.response.close();
          break;
        default:
          request.response.statusCode = HttpStatus.notFound;
          await request.response.close();
      }
    } catch (e) {
      request.response.statusCode = HttpStatus.internalServerError;
      await request.response.close();
    }
  }

  Future<void> _handleSync(HttpRequest request) async {
    final body = await utf8.decoder.bind(request).join();
    final data = jsonDecode(body) as Map<String, dynamic>;

    final syncEvent = SyncEvent.fromJson(data);
    _syncController.add(syncEvent);

    request.response.write('{"status":"ok"}');
    await request.response.close();
  }

  /// 发送数据到目标设备
  Future<void> sendToDevice(String ipAddress, SyncEvent event) async {
    try {
      final client = HttpClient();
      final request = await client.postUrl(
        Uri.parse('http://$ipAddress:$_transferPort/sync'),
      );
      request.headers.contentType = ContentType.json;
      request.write(jsonEncode(event.toJson()));
      await request.close();
      client.close();
    } catch (e) {
      debugPrint('Send to device failed: $e');
      rethrow;
    }
  }

  void dispose() {
    _server?.close();
    _syncController.close();
  }
}

/// 同步事件
class SyncEvent {
  final String deviceId;
  final String entityType;
  final int entityId;
  final SyncOperation operation;
  final Map<String, dynamic> data;
  final int timestamp;
  final int localVersion;

  SyncEvent({
    required this.deviceId,
    required this.entityType,
    required this.entityId,
    required this.operation,
    required this.data,
    required this.timestamp,
    required this.localVersion,
  });

  factory SyncEvent.fromJson(Map<String, dynamic> json) {
    return SyncEvent(
      deviceId: json['device_id'] as String,
      entityType: json['entity_type'] as String,
      entityId: json['entity_id'] as int,
      operation: SyncOperation.values.firstWhere(
        (e) => e.name == json['operation'],
        orElse: () => SyncOperation.update,
      ),
      data: json['data'] as Map<String, dynamic>,
      timestamp: json['timestamp'] as int,
      localVersion: json['local_version'] as int? ?? 0,
    );
  }

  Map<String, dynamic> toJson() => {
        'device_id': deviceId,
        'entity_type': entityType,
        'entity_id': entityId,
        'operation': operation.name,
        'data': data,
        'timestamp': timestamp,
        'local_version': localVersion,
      };
}

enum SyncOperation {
  create,
  update,
  delete,
}
```

### 3.4 同步状态管理

#### 3.4.1 Provider

```dart
// lib/presentation/providers/sync_provider.dart

import 'package:flutter_riverpod/flutter_riverpod.dart';

/// 同步状态
enum SyncState {
  disconnected,   // 未连接
  connecting,      // 连接中
  connected,       // 已连接
  syncing,         // 同步中
  synced,          // 已同步
  error,           // 错误
  offline,         // 离线
}

/// 同步状态 Provider
final syncStateProvider = StateNotifierProvider<SyncStateNotifier, SyncState>((ref) {
  return SyncStateNotifier();
});

class SyncStateNotifier extends StateNotifier<SyncState> {
  SyncStateNotifier() : super(SyncState.disconnected);

  void updateState(SyncState newState) {
    state = newState;
  }

  // 连接设备
  Future<void> connectDevice(DiscoveredDevice device) async {
    state = SyncState.connecting;
    try {
      // 验证连接
      // 发起配对请求
      state = SyncState.connected;
    } catch (e) {
      state = SyncState.error;
    }
  }

  // 断开设备
  Future<void> disconnectDevice(String deviceId) async {
    state = SyncState.disconnected;
  }

  // 手动同步
  Future<void> syncNow() async {
    if (state != SyncState.connected) return;

    state = SyncState.syncing;
    try {
      // 执行同步
      await Future.delayed(const Duration(seconds: 1));
      state = SyncState.synced;
    } catch (e) {
      state = SyncState.error;
    }
  }
}

/// 已连接设备列表
final connectedDevicesProvider = StateProvider<List<ConnectedDevice>>((ref) => []);

class ConnectedDevice {
  final String deviceId;
  final String deviceName;
  final String deviceType;
  final String ipAddress;
  final bool isMaster;

  ConnectedDevice({
    required this.deviceId,
    required this.deviceName,
    required this.deviceType,
    required this.ipAddress,
    this.isMaster = false,
  });
}
```

### 3.5 配对流程

#### 3.5.1 配对码生成与验证

```dart
// lib/infrastructure/sync/pairing_service.dart

import 'dart:math';

/// 配对服务
class PairingService {
  /// 生成 6 位配对码
  static String generatePairingCode() {
    final random = Random();
    return List.generate(6, (_) => random.nextInt(10)).join();
  }

  /// 验证配对码
  static bool verifyPairingCode(String input, String expected) {
    return input == expected;
  }

  /// 配对码有效期（5 分钟）
  static const Duration pairingCodeValidity = Duration(minutes: 5);
}
```

---

## 四、数据库迁移

### 4.1 v3.0 数据库版本

```dart
// lib/data/database/database.dart

@override
int get schemaVersion => 3;

@override
MigrationStrategy get migration => MigrationStrategy(
  onCreate: (migrator) async {
    await migrator.createAll();
  },
  onUpgrade: (migrator, from, to) async {
    // v3.0：新增同步相关表
    if (from < 3) {
      await migrator.createTable(syncDevices);
      await migrator.createTable(syncLogs);
    }
  },
);
```

---

## 五、文件改动清单

### 5.1 现有文件修改

| 文件 | 改动类型 | 说明 |
|------|----------|------|
| `pubspec.yaml` | 修改 | 添加依赖 |
| `lib/main.dart` | 修改 | 桌面端初始化 |
| `lib/infrastructure/router/app_router.dart` | 修改 | 新增路由 |
| `lib/presentation/pages/shell/shell_scaffold.dart` | 修改 | 底部导航 |
| `lib/core/constants/app_strings.dart` | 修改 | 新增字符串 |
| `lib/data/database/database.dart` | 修改 | 数据库迁移 |

### 5.2 新增文件

| 类型 | 文件路径 | 说明 |
|------|----------|------|
| Page | `lib/presentation/pages/help/help_page.dart` | 帮助页 |
| Widget | `lib/presentation/widgets/desktop_title_bar.dart` | 桌面标题栏 |
| Widget | `lib/presentation/widgets/desktop_shortcuts.dart` | 快捷键 |
| Service | `lib/infrastructure/desktop/tray_service.dart` | 托盘服务 |
| Service | `lib/infrastructure/sync/discovery_service.dart` | 设备发现 |
| Service | `lib/infrastructure/sync/transfer_service.dart` | 数据传输 |
| Service | `lib/infrastructure/sync/pairing_service.dart` | 配对服务 |
| Provider | `lib/presentation/providers/sync_provider.dart` | 同步状态 |
| Table | `lib/data/database/tables/sync_devices_table.dart` | 设备表 |
| Table | `lib/data/database/tables/sync_logs_table.dart` | 日志表 |
| DAO | `lib/data/database/daos/sync_device_dao.dart` | 设备 DAO |
| Utils | `lib/core/utils/responsive_utils.dart` | 响应式工具 |
| Asset | `assets/markdown/learning_guide.md` | 学习指南 |
| Asset | `assets/icons/app_icon.png` | 应用图标 |
| Asset | `assets/icons/app_icon_syncing.png` | 同步中图标 |
| Asset | `assets/icons/app_icon_offline.png` | 离线图标 |

---

## 六、测试计划

### 6.1 单元测试

| 组件 | 测试内容 |
|------|----------|
| DiscoveryService | 设备发现、广播 |
| TransferService | 数据发送、接收 |
| PairingService | 配对码生成、验证 |
| SyncProvider | 状态变更 |

### 6.2 集成测试

| 场景 | 测试内容 |
|------|----------|
| 帮助页 | Markdown 渲染、主题适配 |
| 桌面端 | 窗口管理、托盘、快捷键 |
| 同步 | 设备发现、配对、数据同步 |

### 6.3 验收测试

| 平台 | 测试项 |
|------|--------|
| Android | 学习指南、主题切换 |
| iOS | 学习指南、主题切换 |
| Windows | 全部功能 |

---

## 七、风险与应对

| 风险 | 影响 | 应对策略 |
|------|------|----------|
| 端口被占用 | 设备发现失败 | 降级为 HTTP Polling |
| 防火墙阻止 | 连接失败 | 提示用户开放端口 |
| 同步冲突 | 数据覆盖 | Last-Write-Wins |
| 桌面端性能 | 卡顿 | 优化列表渲染 |
| 托盘图标缺失 | 功能异常 | 提供默认图标兜底 |

---

*本文档为忆刻 v3.0 技术设计文档，详细实现请参考代码注释。*
