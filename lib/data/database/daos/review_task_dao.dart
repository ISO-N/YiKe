/// 文件用途：ReviewTaskDao - 复习任务数据库访问封装（Drift）。
/// 作者：Codex
/// 创建日期：2026-02-25
library;

import 'package:drift/drift.dart';
import 'package:uuid/uuid.dart';

import '../../../core/utils/date_utils.dart';
import '../../../domain/entities/task_day_stats.dart';
import '../../models/review_task_with_item_model.dart';
import '../../models/review_task_timeline_model.dart';
import '../database.dart';

/// 复习任务 DAO。
///
/// 说明：封装复习任务相关的 CRUD、状态更新及常用查询（今日/逾期/统计等）。
class ReviewTaskDao {
  /// 构造函数。
  ///
  /// 参数：
  /// - [db] 数据库实例。
  /// 异常：无。
  ReviewTaskDao(this.db);

  final AppDatabase db;

  static const Uuid _uuid = Uuid();

  /// 插入复习任务。
  ///
  /// 返回值：新记录 ID。
  /// 异常：数据库写入失败时可能抛出异常。
  Future<int> insertReviewTask(ReviewTasksCompanion companion) {
    return db.into(db.reviewTasks).insert(companion);
  }

  /// 批量插入复习任务。
  ///
  /// 返回值：Future（无返回值）。
  /// 异常：数据库写入失败时可能抛出异常。
  Future<void> insertReviewTasks(List<ReviewTasksCompanion> companions) async {
    await db.batch((batch) {
      batch.insertAll(db.reviewTasks, companions);
    });
  }

  /// 更新复习任务。
  ///
  /// 返回值：是否更新成功。
  /// 异常：数据库更新失败时可能抛出异常。
  Future<bool> updateReviewTask(ReviewTask task) {
    return db.update(db.reviewTasks).replace(task);
  }

  /// 更新任务状态。
  ///
  /// 参数：
  /// - [id] 任务 ID
  /// - [status] 状态（pending/done/skipped）
  /// - [completedAt] 完成时间（done 时建议传入）
  /// - [skippedAt] 跳过时间（skipped 时建议传入）
  /// 返回值：更新行数。
  /// 异常：数据库更新失败时可能抛出异常。
  Future<int> updateTaskStatus(
    int id,
    String status, {
    DateTime? completedAt,
    DateTime? skippedAt,
  }) async {
    // 规格增强：已停用学习内容禁止任何任务状态变更。
    await _assertLearningItemActiveByTaskIds([id]);
    final now = DateTime.now();
    return (db.update(db.reviewTasks)..where((t) => t.id.equals(id))).write(
      ReviewTasksCompanion(
        status: Value(status),
        completedAt: Value(completedAt),
        skippedAt: Value(skippedAt),
        updatedAt: Value(now),
      ),
    );
  }

  /// 标记任务完成（done）并写入一条复习记录（review_records）。
  ///
  /// 说明：
  /// - 使用事务确保“任务状态 + 记录”一致
  /// - occurredAt 使用当前时间（与 completedAt 一致）
  Future<void> completeTaskWithRecord(int id) async {
    final now = DateTime.now();
    await db.transaction(() async {
      await updateTaskStatus(id, 'done', completedAt: now);
      await _insertRecord(reviewTaskId: id, action: 'done', occurredAt: now);
    });
  }

  /// 标记任务跳过（skipped）并写入一条复习记录（review_records）。
  Future<void> skipTaskWithRecord(int id) async {
    final now = DateTime.now();
    await db.transaction(() async {
      await updateTaskStatus(id, 'skipped', skippedAt: now);
      await _insertRecord(reviewTaskId: id, action: 'skipped', occurredAt: now);
    });
  }

  /// 批量标记任务完成并写入复习记录（review_records）。
  ///
  /// 说明：在同一事务内执行，避免部分成功导致口径不一致。
  Future<void> completeTasksWithRecords(List<int> ids) async {
    if (ids.isEmpty) return;
    final now = DateTime.now();
    await db.transaction(() async {
      await updateTaskStatusBatch(ids, 'done', timestamp: now);
      await _insertRecords(ids, action: 'done', occurredAt: now);
    });
  }

  /// 批量标记任务跳过并写入复习记录（review_records）。
  Future<void> skipTasksWithRecords(List<int> ids) async {
    if (ids.isEmpty) return;
    final now = DateTime.now();
    await db.transaction(() async {
      await updateTaskStatusBatch(ids, 'skipped', timestamp: now);
      await _insertRecords(ids, action: 'skipped', occurredAt: now);
    });
  }

  /// 批量更新任务状态。
  ///
  /// 参数：
  /// - [ids] 任务 ID 列表
  /// - [status] 目标状态
  /// - [timestamp] 对应状态的时间戳（done 使用 completedAt，skipped 使用 skippedAt）
  /// 返回值：更新行数。
  /// 异常：数据库更新失败时可能抛出异常。
  Future<int> updateTaskStatusBatch(
    List<int> ids,
    String status, {
    DateTime? timestamp,
  }) async {
    if (ids.isEmpty) return Future.value(0);
    // 规格增强：已停用学习内容禁止任何任务状态变更。
    await _assertLearningItemActiveByTaskIds(ids);

    final now = DateTime.now();
    final companion = ReviewTasksCompanion(
      status: Value(status),
      completedAt: Value(status == 'done' ? timestamp : null),
      skippedAt: Value(status == 'skipped' ? timestamp : null),
      updatedAt: Value(now),
    );

    return (db.update(
      db.reviewTasks,
    )..where((t) => t.id.isIn(ids))).write(companion);
  }

  /// 根据 ID 查询复习任务。
  ///
  /// 返回值：复习任务或 null。
  /// 异常：数据库查询失败时可能抛出异常。
  Future<ReviewTask?> getReviewTaskById(int id) {
    return (db.select(
      db.reviewTasks,
    )..where((t) => t.id.equals(id))).getSingleOrNull();
  }

  /// 查询指定日期的所有复习任务（包含完成/跳过）。
  ///
  /// 参数：
  /// - [date] 目标日期（按年月日）。
  /// 返回值：任务列表（按 scheduledDate 升序）。
  /// 异常：数据库查询失败时可能抛出异常。
  Future<List<ReviewTask>> getTasksByDate(DateTime date) {
    final start = DateTime(date.year, date.month, date.day);
    final end = start.add(const Duration(days: 1));
    return (db.select(db.reviewTasks)
          ..where((t) => t.scheduledDate.isBiggerOrEqualValue(start))
          ..where((t) => t.scheduledDate.isSmallerThanValue(end))
          ..orderBy([(t) => OrderingTerm.asc(t.scheduledDate)]))
        .get();
  }

  /// 查询指定日期的所有复习任务（join 学习内容，用于展示/小组件）。
  ///
  /// 说明：包含 pending/done/skipped。
  Future<List<ReviewTaskWithItemModel>> getTasksByDateWithItem(
    DateTime date,
  ) async {
    final start = DateTime(date.year, date.month, date.day);
    final end = start.add(const Duration(days: 1));

    final task = db.reviewTasks;
    final item = db.learningItems;

    final query =
        db.select(task).join([
            innerJoin(item, item.id.equalsExp(task.learningItemId)),
          ])
          ..where(item.isDeleted.equals(false))
          ..where(task.scheduledDate.isBiggerOrEqualValue(start))
          ..where(task.scheduledDate.isSmallerThanValue(end))
          ..orderBy([
            OrderingTerm.asc(task.status),
            OrderingTerm.asc(task.reviewRound),
          ]);

    final rows = await query.get();
    return rows
        .map(
          (row) => ReviewTaskWithItemModel(
            task: row.readTable(task),
            item: row.readTable(item),
          ),
        )
        .toList();
  }

  /// 查询今日待复习任务（pending，scheduledDate=今日）。
  Future<List<ReviewTaskWithItemModel>> getTodayPendingTasksWithItem() {
    return _getTasksWithItem(
      date: DateTime.now(),
      onlyPending: true,
      onlyOverdue: false,
    );
  }

  /// 查询逾期任务（pending，scheduledDate < 今日）。
  Future<List<ReviewTaskWithItemModel>> getOverdueTasksWithItem() {
    return _getTasksWithItem(
      date: DateTime.now(),
      onlyPending: true,
      onlyOverdue: true,
    );
  }

  /// 查询今日已完成任务（done，completedAt=今日）。
  ///
  /// 说明：按 completedAt 的自然日口径统计，不受 scheduledDate 影响。
  Future<List<ReviewTaskWithItemModel>> getTodayCompletedTasksWithItem({
    DateTime? today,
  }) async {
    final now = today ?? DateTime.now();
    final start = YikeDateUtils.atStartOfDay(now);
    final end = start.add(const Duration(days: 1));

    final task = db.reviewTasks;
    final item = db.learningItems;

    final query =
        db.select(task).join([
            innerJoin(item, item.id.equalsExp(task.learningItemId)),
          ])
          ..where(item.isDeleted.equals(false))
          ..where(task.status.equals('done'))
          ..where(task.completedAt.isBiggerOrEqualValue(start))
          ..where(task.completedAt.isSmallerThanValue(end))
          ..orderBy([
            OrderingTerm.desc(task.completedAt),
            OrderingTerm.desc(task.id),
          ]);

    final rows = await query.get();
    return rows
        .map(
          (row) => ReviewTaskWithItemModel(
            task: row.readTable(task),
            item: row.readTable(item),
          ),
        )
        .toList();
  }

  /// 查询今日已跳过任务（skipped，skippedAt=今日）。
  ///
  /// 说明：按 skippedAt 的自然日口径统计，不受 scheduledDate 影响。
  Future<List<ReviewTaskWithItemModel>> getTodaySkippedTasksWithItem({
    DateTime? today,
  }) async {
    final now = today ?? DateTime.now();
    final start = YikeDateUtils.atStartOfDay(now);
    final end = start.add(const Duration(days: 1));

    final task = db.reviewTasks;
    final item = db.learningItems;

    final query =
        db.select(task).join([
            innerJoin(item, item.id.equalsExp(task.learningItemId)),
          ])
          ..where(item.isDeleted.equals(false))
          ..where(task.status.equals('skipped'))
          ..where(task.skippedAt.isBiggerOrEqualValue(start))
          ..where(task.skippedAt.isSmallerThanValue(end))
          ..orderBy([OrderingTerm.desc(task.skippedAt), OrderingTerm.desc(task.id)]);

    final rows = await query.get();
    return rows
        .map(
          (row) => ReviewTaskWithItemModel(
            task: row.readTable(task),
            item: row.readTable(item),
          ),
        )
        .toList();
  }

  /// 撤销任务状态（done/skipped → pending）。
  ///
  /// 规则：
  /// - status 设置为 pending
  /// - completedAt/skippedAt 清空（两者都清空，避免历史脏数据影响口径）
  /// 返回值：更新行数。
  Future<int> undoTaskStatus(int id) async {
    // 规格增强：已停用学习内容禁止任何任务状态变更。
    await _assertLearningItemActiveByTaskIds([id]);
    final now = DateTime.now();
    return (db.update(db.reviewTasks)..where((t) => t.id.equals(id))).write(
      ReviewTasksCompanion(
        status: const Value('pending'),
        completedAt: const Value(null),
        skippedAt: const Value(null),
        updatedAt: Value(now),
      ),
    );
  }

  /// 撤销任务状态并写入一条复习记录（review_records）。
  ///
  /// 说明：撤销同样属于行为事件，便于审计与未来扩展。
  Future<void> undoTaskStatusWithRecord(int id) async {
    final now = DateTime.now();
    await db.transaction(() async {
      await undoTaskStatus(id);
      await _insertRecord(reviewTaskId: id, action: 'undo', occurredAt: now);
    });
  }

  /// 插入单条复习记录。
  Future<void> _insertRecord({
    required int reviewTaskId,
    required String action,
    required DateTime occurredAt,
  }) async {
    await db.into(db.reviewRecords).insert(
      ReviewRecordsCompanion.insert(
        uuid: Value(_uuid.v4()),
        reviewTaskId: reviewTaskId,
        action: action,
        occurredAt: occurredAt,
        createdAt: Value(occurredAt),
      ),
    );
  }

  /// 批量插入复习记录（同一 action/occurredAt）。
  Future<void> _insertRecords(
    List<int> reviewTaskIds, {
    required String action,
    required DateTime occurredAt,
  }) async {
    final companions = reviewTaskIds
        .map(
          (id) => ReviewRecordsCompanion.insert(
            uuid: Value(_uuid.v4()),
            reviewTaskId: id,
            action: action,
            occurredAt: occurredAt,
            createdAt: Value(occurredAt),
          ),
        )
        .toList();

    await db.batch((batch) {
      batch.insertAll(db.reviewRecords, companions);
    });
  }

  /// 获取全量任务状态计数（用于任务中心筛选栏展示）。
  ///
  /// 返回值：(all, pending, done, skipped)。
  Future<(int all, int pending, int done, int skipped)>
  getGlobalTaskStatusCounts() async {
    const sql = '''
SELECT
  COUNT(*) AS all_count,
  SUM(CASE WHEN rt.status='pending' THEN 1 ELSE 0 END) AS pending_count,
  SUM(CASE WHEN rt.status='done' THEN 1 ELSE 0 END) AS done_count,
  SUM(CASE WHEN rt.status='skipped' THEN 1 ELSE 0 END) AS skipped_count
FROM review_tasks rt
INNER JOIN learning_items li ON li.id = rt.learning_item_id
WHERE li.is_deleted = 0
''';
    final row = await db.customSelect(sql, readsFrom: {db.reviewTasks, db.learningItems}).getSingle();
    return (
      row.read<int?>('all_count') ?? 0,
      row.read<int?>('pending_count') ?? 0,
      row.read<int?>('done_count') ?? 0,
      row.read<int?>('skipped_count') ?? 0,
    );
  }

  /// 按“发生时间”倒序获取任务时间线分页数据（用于任务中心）。
  ///
  /// 说明：
  /// - pending：occurredAt = scheduled_date
  /// - done：occurredAt = COALESCE(completed_at, scheduled_date)
  /// - skipped：occurredAt = COALESCE(skipped_at, scheduled_date)
  /// - 排序：occurredAt ASC, taskId ASC（稳定排序）
  /// - 游标：下一页取“当前页最后一条”，查询条件为 (occurredAt > cursor) OR (occurredAt = cursor AND taskId > cursorId)
  Future<List<ReviewTaskTimelineModel>> getTaskTimelinePageWithItem({
    String? status,
    DateTime? cursorOccurredAt,
    int? cursorTaskId,
    int limit = 20,
  }) async {
    final where = StringBuffer();
    final variables = <Variable>[];

    where.write('1=1');
    if (status != null) {
      where.write(' AND rt.status = ?');
      variables.add(Variable<String>(status));
    }

    const occurredSql = '''
CASE rt.status
  WHEN 'pending' THEN rt.scheduled_date
  WHEN 'done' THEN COALESCE(rt.completed_at, rt.scheduled_date)
  WHEN 'skipped' THEN COALESCE(rt.skipped_at, rt.scheduled_date)
  ELSE rt.scheduled_date
END
''';

    final cursorWhere = StringBuffer();
    final cursorVars = <Variable>[];
    if (cursorOccurredAt != null && cursorTaskId != null) {
      cursorWhere.write(
        'WHERE (t.occurred_at > ? OR (t.occurred_at = ? AND t."rt.id" > ?))',
      );
      cursorVars.add(Variable<DateTime>(cursorOccurredAt));
      cursorVars.add(Variable<DateTime>(cursorOccurredAt));
      cursorVars.add(Variable<int>(cursorTaskId));
    }

    final sql = '''
 SELECT * FROM (
  SELECT
    rt.id AS "rt.id",
    rt.uuid AS "rt.uuid",
    rt.learning_item_id AS "rt.learning_item_id",
    rt.review_round AS "rt.review_round",
    rt.scheduled_date AS "rt.scheduled_date",
    rt.status AS "rt.status",
    rt.completed_at AS "rt.completed_at",
    rt.skipped_at AS "rt.skipped_at",
    rt.created_at AS "rt.created_at",
    rt.updated_at AS "rt.updated_at",
    rt.is_mock_data AS "rt.is_mock_data",

    li.id AS "li.id",
    li.uuid AS "li.uuid",
    li.title AS "li.title",
    li.note AS "li.note",
     li.tags AS "li.tags",
     li.learning_date AS "li.learning_date",
     li.created_at AS "li.created_at",
     li.updated_at AS "li.updated_at",
     li.is_deleted AS "li.is_deleted",
     li.deleted_at AS "li.deleted_at",
     li.is_mock_data AS "li.is_mock_data",

     $occurredSql AS occurred_at
   FROM review_tasks rt
   INNER JOIN learning_items li ON li.id = rt.learning_item_id
   WHERE li.is_deleted = 0 AND ${where.toString()}
 ) t
 ${cursorWhere.toString()}
 ORDER BY t.occurred_at ASC, t."rt.id" ASC
 LIMIT ?
 ''';

    final rows =
        await db.customSelect(
          sql,
          variables: [...variables, ...cursorVars, Variable<int>(limit)],
          readsFrom: {db.reviewTasks, db.learningItems},
        ).get();

    return rows
        .map((row) {
          final task = db.reviewTasks.map(row.data, tablePrefix: 'rt');
          final item = db.learningItems.map(row.data, tablePrefix: 'li');
          final occurredAt = row.read<DateTime>('occurred_at');
          return ReviewTaskTimelineModel(
            model: ReviewTaskWithItemModel(task: task, item: item),
            occurredAt: occurredAt,
          );
        })
        .toList();
  }

  /// 查询学习内容关联的所有复习任务。
  Future<List<ReviewTask>> getTasksByLearningItemId(int learningItemId) {
    return (db.select(
      db.reviewTasks,
    )..where((t) => t.learningItemId.equals(learningItemId))).get();
  }

  /// 查询学习内容的复习计划（join 学习内容，用于详情 Sheet）。
  ///
  /// 说明：
  /// - 不过滤 is_deleted，详情页需要展示“已停用只读模式”
  /// - 按 reviewRound 正序返回
  Future<List<ReviewTaskWithItemModel>> getReviewPlanWithItem(
    int learningItemId,
  ) async {
    final task = db.reviewTasks;
    final item = db.learningItems;
    final query =
        db.select(task).join([
            innerJoin(item, item.id.equalsExp(task.learningItemId)),
          ])
          ..where(item.id.equals(learningItemId))
          ..orderBy([OrderingTerm.asc(task.reviewRound), OrderingTerm.asc(task.id)]);

    final rows = await query.get();
    return rows
        .map(
          (row) => ReviewTaskWithItemModel(
            task: row.readTable(task),
            item: row.readTable(item),
          ),
        )
        .toList();
  }

  /// 根据 learningItemId + reviewRound 定位唯一复习任务记录。
  Future<ReviewTask?> getTaskByLearningItemAndRound(
    int learningItemId,
    int reviewRound,
  ) {
    return (db.select(db.reviewTasks)
          ..where((t) => t.learningItemId.equals(learningItemId))
          ..where((t) => t.reviewRound.equals(reviewRound)))
        .getSingleOrNull();
  }

  /// 更新指定轮次的 scheduledDate（定位键：learningItemId + reviewRound）。
  ///
  /// 返回值：更新行数。
  Future<int> updateScheduledDateByLearningItemAndRound({
    required int learningItemId,
    required int reviewRound,
    required DateTime scheduledDate,
  }) {
    final now = DateTime.now();
    return (db.update(db.reviewTasks)
          ..where((t) => t.learningItemId.equals(learningItemId))
          ..where((t) => t.reviewRound.equals(reviewRound)))
        .write(
          ReviewTasksCompanion(
            scheduledDate: Value(scheduledDate),
            updatedAt: Value(now),
          ),
        );
  }

  /// 获取指定学习内容当前最大复习轮次（不存在则返回 0）。
  Future<int> getMaxReviewRound(int learningItemId) async {
    final exp = db.reviewTasks.reviewRound.max();
    final row =
        await (db.selectOnly(db.reviewTasks)
              ..addColumns([exp])
              ..where(db.reviewTasks.learningItemId.equals(learningItemId)))
            .getSingle();
    return row.read(exp) ?? 0;
  }

  /// 获取指定日期任务统计（completed/total）。
  ///
  /// 说明：total 包含 done/skipped/pending，completed 仅统计 done。
  Future<(int completed, int total)> getTaskStats(DateTime date) async {
    final start = DateTime(date.year, date.month, date.day);
    final end = start.add(const Duration(days: 1));

    const sql = '''
SELECT
  COUNT(*) AS total_count,
  SUM(CASE WHEN rt.status='done' THEN 1 ELSE 0 END) AS completed_count
FROM review_tasks rt
INNER JOIN learning_items li ON li.id = rt.learning_item_id
WHERE li.is_deleted = 0
  AND rt.scheduled_date >= ?
  AND rt.scheduled_date < ?
''';
    final row = await db.customSelect(
      sql,
      variables: [Variable<DateTime>(start), Variable<DateTime>(end)],
      readsFrom: {db.reviewTasks, db.learningItems},
    ).getSingle();
    return (
      row.read<int?>('completed_count') ?? 0,
      row.read<int?>('total_count') ?? 0,
    );
  }

  /// F6：获取指定月份每天的任务统计（用于日历圆点标记）。
  ///
  /// 参数：
  /// - [year] 年份
  /// - [month] 月份（1-12）
  /// 返回值：以当天 00:00 为 key 的统计 Map。
  /// 异常：数据库查询失败时可能抛出异常。
  Future<Map<DateTime, TaskDayStats>> getMonthlyTaskStats(
    int year,
    int month,
  ) async {
    final start = DateTime(year, month, 1);
    final end = DateTime(year, month + 1, 1);

    const sql = '''
SELECT rt.scheduled_date AS scheduled_date, rt.status AS status
FROM review_tasks rt
INNER JOIN learning_items li ON li.id = rt.learning_item_id
WHERE li.is_deleted = 0
  AND rt.scheduled_date >= ?
  AND rt.scheduled_date < ?
''';
    final rows = await db.customSelect(
      sql,
      variables: [Variable<DateTime>(start), Variable<DateTime>(end)],
      readsFrom: {db.reviewTasks, db.learningItems},
    ).get();
    final map = <DateTime, _DayStatsAccumulator>{};
    for (final row in rows) {
      final scheduled = row.read<DateTime>('scheduled_date');
      final status = row.read<String?>('status') ?? 'pending';
      final day = YikeDateUtils.atStartOfDay(scheduled);
      final stats = map.putIfAbsent(day, _DayStatsAccumulator.new);
      switch (status) {
        case 'done':
          stats.done++;
          break;
        case 'skipped':
          stats.skipped++;
          break;
        case 'pending':
        default:
          stats.pending++;
          break;
      }
    }

    return map.map(
      (day, stats) => MapEntry(
        day,
        TaskDayStats(
          pendingCount: stats.pending,
          doneCount: stats.done,
          skippedCount: stats.skipped,
        ),
      ),
    );
  }

  /// F6：获取指定日期范围的任务列表（join 学习内容）。
  ///
  /// 参数：
  /// - [start] 起始时间（包含）
  /// - [end] 结束时间（不包含）
  /// 返回值：任务列表（按 scheduledDate 升序）。
  /// 异常：数据库查询失败时可能抛出异常。
  Future<List<ReviewTaskWithItemModel>> getTasksInRange(
    DateTime start,
    DateTime end,
  ) async {
    final task = db.reviewTasks;
    final item = db.learningItems;

    final query =
        db.select(task).join([
            innerJoin(item, item.id.equalsExp(task.learningItemId)),
          ])
          ..where(item.isDeleted.equals(false))
          ..where(task.scheduledDate.isBiggerOrEqualValue(start))
          ..where(task.scheduledDate.isSmallerThanValue(end))
          ..orderBy([
            OrderingTerm.asc(task.scheduledDate),
            OrderingTerm.asc(task.status),
            OrderingTerm.asc(task.reviewRound),
          ]);

    final rows = await query.get();
    return rows
        .map(
          (row) => ReviewTaskWithItemModel(
            task: row.readTable(task),
            item: row.readTable(item),
          ),
        )
        .toList();
  }

  /// F7：获取连续打卡天数（从今天往前计算）。
  ///
  /// 口径：
  /// - 连续每天至少完成 1 条任务即算打卡成功（done>=1 记 1 天）
  /// - 某天存在 pending 且 done=0 则断签
  /// - skipped 不计入断签，也不计入完成
  /// - 某天没有任务，不中断打卡链
  Future<int> getConsecutiveCompletedDays({DateTime? today}) async {
    final now = today ?? DateTime.now();
    final todayStart = YikeDateUtils.atStartOfDay(now);
    final todayEnd = todayStart.add(const Duration(days: 1));

    final task = db.reviewTasks;
    final item = db.learningItems;

    // 找到最早的“done/pending”任务日期作为遍历下界，避免无穷回溯。
    final earliestRow =
        await (db.select(task).join([
              innerJoin(item, item.id.equalsExp(task.learningItemId)),
            ])
              ..where(item.isDeleted.equals(false))
              ..where(task.scheduledDate.isSmallerThanValue(todayEnd))
              ..where(task.status.isIn(const ['done', 'pending']))
              ..orderBy([OrderingTerm.asc(task.scheduledDate)])
              ..limit(1))
            .getSingleOrNull();

    final earliest = earliestRow?.readTable(task).scheduledDate;
    if (earliest == null) return 0;
    final earliestStart = YikeDateUtils.atStartOfDay(earliest);

    // 一次性拉取范围内的 done/pending 任务，再在 Dart 侧按天聚合（排除已停用学习内容）。
    final joined =
        await (db.select(task).join([
              innerJoin(item, item.id.equalsExp(task.learningItemId)),
            ])
              ..where(item.isDeleted.equals(false))
              ..where(task.scheduledDate.isBiggerOrEqualValue(earliestStart))
              ..where(task.scheduledDate.isSmallerThanValue(todayEnd))
              ..where(task.status.isIn(const ['done', 'pending'])))
            .get();
    final tasks = joined.map((r) => r.readTable(task)).toList();

    final dayMap = <DateTime, _DayStatsAccumulator>{};
    for (final task in tasks) {
      final day = YikeDateUtils.atStartOfDay(task.scheduledDate);
      final stats = dayMap.putIfAbsent(day, _DayStatsAccumulator.new);
      if (task.status == 'done') {
        stats.done++;
      } else {
        stats.pending++;
      }
    }

    var streak = 0;
    for (
      var cursor = todayStart;
      !cursor.isBefore(earliestStart);
      cursor = cursor.subtract(const Duration(days: 1))
    ) {
      final stats = dayMap[cursor];
      final pending = stats?.pending ?? 0;
      final done = stats?.done ?? 0;

      if (pending > 0 && done == 0) {
        // 当天有待复习但没有完成，断签。
        break;
      }

      if (done > 0) {
        streak++;
      }
    }

    return streak;
  }

  /// F7：获取指定日期范围的完成率口径数据（completed/total）。
  ///
  /// 说明：
  /// - completed：done 数量
  /// - total：done + pending 数量（skipped 不参与）
  Future<(int completed, int total)> getTaskStatsInRange(
    DateTime start,
    DateTime end,
  ) async {
    const sql = '''
SELECT
  SUM(CASE WHEN rt.status IN ('done','pending') THEN 1 ELSE 0 END) AS total_count,
  SUM(CASE WHEN rt.status='done' THEN 1 ELSE 0 END) AS completed_count
FROM review_tasks rt
INNER JOIN learning_items li ON li.id = rt.learning_item_id
WHERE li.is_deleted = 0
  AND rt.scheduled_date >= ?
  AND rt.scheduled_date < ?
''';
    final row = await db.customSelect(
      sql,
      variables: [Variable<DateTime>(start), Variable<DateTime>(end)],
      readsFrom: {db.reviewTasks, db.learningItems},
    ).getSingle();
    final total = row.read<int?>('total_count') ?? 0;
    final completed = row.read<int?>('completed_count') ?? 0;
    return (completed, total);
  }

  /// F8：获取全部复习任务（用于数据导出）。
  Future<List<ReviewTask>> getAllTasks() {
    return db.select(db.reviewTasks).get();
  }

  /// 删除所有模拟复习任务（v3.1 Debug）。
  ///
  /// 说明：按 isMockData=true 条件删除。
  /// 返回值：删除行数。
  /// 异常：数据库删除失败时可能抛出异常。
  Future<int> deleteMockReviewTasks() {
    return (db.delete(
      db.reviewTasks,
    )..where((t) => t.isMockData.equals(true))).go();
  }

  Future<List<ReviewTaskWithItemModel>> _getTasksWithItem({
    required DateTime date,
    required bool onlyPending,
    required bool onlyOverdue,
  }) async {
    final start = DateTime(date.year, date.month, date.day);
    final end = start.add(const Duration(days: 1));

    final task = db.reviewTasks;
    final item = db.learningItems;

    final query = db.select(task).join([
      innerJoin(item, item.id.equalsExp(task.learningItemId)),
    ]);
    query.where(item.isDeleted.equals(false));

    if (onlyOverdue) {
      query.where(task.scheduledDate.isSmallerThanValue(start));
    } else {
      query.where(task.scheduledDate.isBiggerOrEqualValue(start));
      query.where(task.scheduledDate.isSmallerThanValue(end));
    }

    if (onlyPending) {
      query.where(task.status.equals('pending'));
    }

    query.orderBy([
      OrderingTerm.asc(task.scheduledDate),
      OrderingTerm.asc(task.reviewRound),
    ]);

    final rows = await query.get();
    return rows
        .map(
          (row) => ReviewTaskWithItemModel(
            task: row.readTable(task),
            item: row.readTable(item),
          ),
        )
        .toList();
  }

  Future<void> _assertLearningItemActiveByTaskIds(List<int> taskIds) async {
    if (taskIds.isEmpty) return;

    final task = db.reviewTasks;
    final item = db.learningItems;

    final q = db.select(task).join([
      innerJoin(item, item.id.equalsExp(task.learningItemId)),
    ])
      ..where(task.id.isIn(taskIds))
      ..where(item.isDeleted.equals(true))
      ..limit(1);

    final hit = await q.getSingleOrNull();
    if (hit != null) {
      throw StateError('学习内容已停用，无法操作');
    }
  }
}

class _DayStatsAccumulator {
  int pending = 0;
  int done = 0;
  int skipped = 0;
}
